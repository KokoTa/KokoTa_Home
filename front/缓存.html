<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>缓存 | KokoTa&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/KokoTa_Home/assets/css/0.styles.42391945.css" as="style"><link rel="preload" href="/KokoTa_Home/assets/js/app.5aa2fc63.js" as="script"><link rel="preload" href="/KokoTa_Home/assets/js/2.f316d9e6.js" as="script"><link rel="preload" href="/KokoTa_Home/assets/js/28.cc74e010.js" as="script"><link rel="prefetch" href="/KokoTa_Home/assets/js/10.a9408bab.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/11.afe9acb0.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/12.20b684e8.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/13.96a14a48.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/14.7fbab43c.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/15.c94cf8e5.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/16.636c15bf.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/17.61b345d1.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/18.6438c8af.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/19.a7367e7f.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/20.afbf2002.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/21.189a1078.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/22.024a4a11.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/23.781c0901.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/24.25347c92.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/25.713bc585.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/26.84be1e5d.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/27.a914d101.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/29.8c624b89.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/3.137d0a24.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/30.db83752a.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/31.8a4e8fdb.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/32.27e1eac7.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/33.49f44af8.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/34.242d9c41.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/35.2da8abc4.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/36.8e90cb74.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/37.ddbb7313.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/38.46018d6a.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/39.126f7b49.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/4.a018097d.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/40.52371e0b.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/41.dc35554b.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/42.90cf799c.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/43.417fb137.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/44.b5b86393.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/45.62db7fc8.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/46.33329211.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/47.5dd730b0.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/48.8bf9775b.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/49.4aa4884e.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/5.f4fd9258.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/6.768d9e6b.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/7.37408dde.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/8.34002bbc.js"><link rel="prefetch" href="/KokoTa_Home/assets/js/9.e96cfb2c.js">
    <link rel="stylesheet" href="/KokoTa_Home/assets/css/0.styles.42391945.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/KokoTa_Home/" class="home-link router-link-active"><!----> <span class="site-name">KokoTa's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/KokoTa_Home/front/" class="sidebar-heading clickable router-link-active open"><span>旧文章迁移</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/KokoTa_Home/front/盒模型与BFC与布局.html" class="sidebar-link">盒模型与BFC与布局</a></li><li><a href="/KokoTa_Home/front/事件与类型.html" class="sidebar-link">事件与类型</a></li><li><a href="/KokoTa_Home/front/HTTP.html" class="sidebar-link">HTTP</a></li><li><a href="/KokoTa_Home/front/原型.html" class="sidebar-link">原型</a></li><li><a href="/KokoTa_Home/front/类与继承.html" class="sidebar-link">类与继承</a></li><li><a href="/KokoTa_Home/front/通信与安全.html" class="sidebar-link">通信与安全</a></li><li><a href="/KokoTa_Home/front/渲染与运行与性能与监控.html" class="sidebar-link">渲染与运行与性能与监控</a></li><li><a href="/KokoTa_Home/front/HTTPS.html" class="sidebar-link">HTTPS</a></li><li><a href="/KokoTa_Home/front/Cookie与Session与Token.html" class="sidebar-link">Cookie与Session与Token</a></li><li><a href="/KokoTa_Home/front/跨域.html" class="sidebar-link">跨域</a></li><li><a href="/KokoTa_Home/front/移动端适配.html" class="sidebar-link">移动端适配</a></li><li><a href="/KokoTa_Home/front/JS精度问题.html" class="sidebar-link">JS精度问题</a></li><li><a href="/KokoTa_Home/front/服务端踩坑日记.html" class="sidebar-link">服务端踩坑日记</a></li><li><a href="/KokoTa_Home/front/前端问题汇总.html" class="sidebar-link">前端问题汇总</a></li><li><a href="/KokoTa_Home/front/微信开发.html" class="sidebar-link">微信开发</a></li><li><a href="/KokoTa_Home/front/JS的this.html" class="sidebar-link">JS的this</a></li><li><a href="/KokoTa_Home/front/缓存.html" class="active sidebar-link">缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/KokoTa_Home/front/缓存.html#缓存分类" class="sidebar-link">缓存分类</a></li><li class="sidebar-sub-header"><a href="/KokoTa_Home/front/缓存.html#service-worker" class="sidebar-link">Service Worker</a></li><li class="sidebar-sub-header"><a href="/KokoTa_Home/front/缓存.html#网络请求" class="sidebar-link">网络请求</a></li><li class="sidebar-sub-header"><a href="/KokoTa_Home/front/缓存.html#浏览器行为" class="sidebar-link">浏览器行为</a></li><li class="sidebar-sub-header"><a href="/KokoTa_Home/front/缓存.html#案例" class="sidebar-link">案例</a></li><li class="sidebar-sub-header"><a href="/KokoTa_Home/front/缓存.html#缓存的应用" class="sidebar-link">缓存的应用</a></li></ul></li><li><a href="/KokoTa_Home/front/MVVM.html" class="sidebar-link">MVVM</a></li><li><a href="/KokoTa_Home/front/混合开发.html" class="sidebar-link">混合开发</a></li><li><a href="/KokoTa_Home/front/直播.html" class="sidebar-link">直播</a></li><li><a href="/KokoTa_Home/front/内网穿透.html" class="sidebar-link">内网穿透</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/KokoTa_Home/question/" class="sidebar-heading clickable"><span>前端知识汇总</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="缓存"><a href="#缓存" class="header-anchor">#</a> 缓存</h1> <h2 id="缓存分类"><a href="#缓存分类" class="header-anchor">#</a> 缓存分类</h2> <p>首先要知道缓存按存储位置分为 <strong>四类</strong>，按缓存时读取的先后顺序排序如下：</p> <ol><li>Service Worker</li> <li>Memory Cache</li> <li>Disk Cache</li> <li>网络请求</li></ol> <h3 id="memory-cache"><a href="#memory-cache" class="header-anchor">#</a> Memory Cache</h3> <p>内存缓存，只在当前浏览器打开的情况下存在的缓存，即关闭浏览器后缓存将被清除。</p> <p>几乎所有类型的资源都能进入内存缓存，但细分下来可以归为两类：</p> <ol><li>preloader。比如 css 中的 <code>@import</code> 内容或者 <code>&lt;video&gt;</code> 的 poster 等。</li> <li>preload。显示指定的预加载资源，比如 <code>&lt;link rel=&quot;preload/prefetch&quot;&gt;</code> 等。</li></ol> <p>内存缓存保证了两个相同的请求下，只会被请求一次 (例如两个 <code>src</code> 相同的图片)。</p> <p>内存缓存会无视 <code>max-age=0、no-cache</code> 等头部配置 (除了 <code>no-store</code>)，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 <code>Content-Type</code>，<code>CORS</code> 等其他特征做校验，即便他们 <code>src</code> 相等 (比如相同的请求地址，但返回的类型不同，则不会读取内存缓存)。</p> <p>如果真心不想让一个资源进入缓存，就连短期的内存缓存也不行，那就需要在头部配置中添加 <code>no-store</code>。</p> <h3 id="disk-cache"><a href="#disk-cache" class="header-anchor">#</a> Disk Cache</h3> <p>硬盘缓存，即持久缓存，它允许相同的资源在跨会话，甚至跨站点的情况下使用，例如两个站点都使用了同一张图片。</p> <p>硬盘缓存严格按照 HTTP 头信息来管理资源。</p> <p>不同浏览器对硬盘缓存的清理算法是不同的。</p> <h4 id="强制缓存"><a href="#强制缓存" class="header-anchor">#</a> 强制缓存</h4> <p>硬盘缓存分为强制缓存和对比缓存。</p> <p>强制缓存就是直接从硬盘里读数据，不发送请求。它直接减少了请求数，是提升最大的缓存策略。</p> <p>可以造成强制缓存的字段是 <code>Cache-control</code> 和 <code>Expires</code>。</p> <h5 id="expires-http-1-0"><a href="#expires-http-1-0" class="header-anchor">#</a> Expires（HTTP 1.0）</h5> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Expires</span><span class="token punctuation">:</span> <span class="token header-value">Thu, 10 Nov 2017 08:45:11 GMT</span></span>
</code></pre></div><p>在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。</p> <p>但是，这个字段设置时有两个缺点：</p> <ol><li>由于是绝对时间，用户可能会将客户端(电脑)本地的时间进行修改，导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑自行修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。</li> <li>写法太复杂了。表示时间的字符串多个空格，少个字母，都会导致非法属性从而设置失效。</li></ol> <h5 id="cache-control-http-1-1"><a href="#cache-control-http-1-1" class="header-anchor">#</a> Cache-control（HTTP/1.1）</h5> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Cache-control</span><span class="token punctuation">:</span> <span class="token header-value">max-age=2592000</span></span>
</code></pre></div><p>这两者的区别就是前者是绝对时间，而后者是相对时间。</p> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener noreferrer">Cache-control 的字段详情<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>其中这里有一个疑问：<code>max-age=0</code> 和 <code>no-cache</code> 等价吗？从规范的字面意思来说，max-age 到期是 应该(SHOULD) 重新验证，而 no-cache 是 必须(MUST) 重新验证。但实际情况以浏览器实现为准，大部分情况他们俩的行为还是一致的。（如果是 max-age=0, must-revalidate 就和 no-cache 等价了）</p> <p>PS1：<code>must-revalidate</code> 加和不加的效果其实是一样的，就算不加浏览器也会自动帮你加。</p> <p>PS2：<code>no-cache</code> 虽然字面意义是 “不要缓存”。但它实际上的机制是，仍然对资源使用缓存，但每一次在使用缓存之前必须（MUST）向服务器对缓存资源进行验证，如果验证通过就读取缓存，验证不通过就把旧缓存删了重新获取资源。</p> <p>PS3：Chrome 默认的缓存时间为 <code>DEFAULT_CACHE_TIME = 300</code>，即 5 分钟，这意味着所有资源除非特殊指定，都会进行缓存。对于其他浏览器，可能会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间</p> <p>PS4：<code>max-age</code> 是在浏览器清除缓存时起作用的字段，表示一定时间内不用请求，直接读取缓存。但如果我们手动清除浏览器缓存后，max-age 也就没什么用了，还是得发送请求获取数据。<code>max-age</code> 和 <code>no-cache</code> 不能同时存在，通过 PS3 大概可以知道 no-cache 的缓存大概是 5 分钟。</p> <p>关于如何使用字段的图例见下：</p> <p><img src="/images/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.jpg" alt="缓存策略"></p> <p>顺带一提，在 HTTP/1.1 之前，如果想使用 no-cache，通常是使用 Pragma 字段，如 Pragma: no-cache (这也是 Pragma 字段唯一的取值)。但是这个字段只是浏览器约定俗成的实现，并没有确切规范，因此缺乏可靠性。它应该只作为一个兼容字段出现，在当前的网络环境下其实用处已经很小。</p> <p>Cache-control 的优先级高于 Expires，为了兼容性考虑，实际项目中两个字段都会设置。</p> <table><thead><tr><th>指令</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td>public</td> <td style="text-align:center;">表示响应可以被客户端&amp;&amp;服务器端缓存</td></tr> <tr><td>private</td> <td style="text-align:center;">只能被客户端缓存</td></tr> <tr><td>max-age=30</td> <td style="text-align:center;">缓存30s后过期，需要重新请求</td></tr> <tr><td>s-maxage=30</td> <td style="text-align:center;">盖max-age，作用同上，只在【代理服务器】生效</td></tr> <tr><td>no-store</td> <td style="text-align:center;">不存</td></tr> <tr><td>no-cache</td> <td style="text-align:center;">缓存并立即失效，下次验证是否过期</td></tr> <tr><td>max-stale=30</td> <td style="text-align:center;">30s内即使失效也用</td></tr> <tr><td>min-fresh</td> <td style="text-align:center;">希望在30s内获取最新的响应</td></tr></tbody></table> <h4 id="对比缓存"><a href="#对比缓存" class="header-anchor">#</a> 对比缓存</h4> <p>当强制缓存失效(超过规定时间)时，就需要使用对比缓存，由服务器决定缓存内容是否失效。</p> <p>对比缓存也是要发送请求的，它主要的优点是可以节省返回的响应体 (比如想要浏览器读取缓存，直接返回 304 状态码就可以了)。</p> <p>对比缓存有两组字段：<code>Last-Modified &amp; If-Modified-Since</code> 和 <code>Etag &amp; If-None-Match</code></p> <h5 id="last-modified-if-modified-since"><a href="#last-modified-if-modified-since" class="header-anchor">#</a> Last-Modified &amp; If-Modified-Since</h5> <p>流程：</p> <ol><li><p>服务器通过 Last-Modified 字段告知客户端，资源最后一次被修改的时间，例如：</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">Last-Modified</span><span class="token punctuation">:</span> <span class="token header-value">Mon, 10 Nov 2018 09:10:11 GMT</span></span>
</code></pre></div></li> <li><p>浏览器将这个值和内容一起记录在缓存中。</p></li> <li><p>下一次请求相同资源时时，浏览器从自己的缓存中找出 “不确定是否过期” 的缓存，将其 Last-Modified 的值写入到请求头的 If-Modified-Since 字段</p></li> <li><p>服务器会将发送过来的 If-Modified-Since 的值与自身的 Last-Modified 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。</p></li></ol> <p>缺点：</p> <ol><li>如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。</li> <li>如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，但还是会导致返回 200 状态码和数据，所以起不到缓存的作用。</li></ol> <h5 id="etag-if-none-match"><a href="#etag-if-none-match" class="header-anchor">#</a> Etag &amp; If-None-Match</h5> <p>Etag 的出现解决了上面的缺点。</p> <p>Etag 存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的 Etag 字段。</p> <p>可以把 Etag 当作文件的 id，每次文件产生变化都会改变这个 id，服务器通过对比这个字段来决定返回的结果，流程和上面一致。</p> <h2 id="service-worker"><a href="#service-worker" class="header-anchor">#</a> Service Worker</h2> <p>上述的缓存类型都是由浏览器内部来控制的，我们只能设置响应头的某些字段来告诉浏览器，而不能自己操作。而 Service Worker 则可以通过编程的方式来缓存数据。</p> <p>Service Worker 将请求返回的数据存储在 Service Worker 数据库中。</p> <p>Service Worker 的缓存是永久的，有两种情况会导致这个缓存中的资源被清除：手动调用 API cache.delete(resource) 或者容量超过限制，被浏览器全部清空。</p> <p>如果 Service Worker 找不到缓存资源，那么它会使用 fetch() 方法，进一步去 Memory Cache 和 Disk Cache 里找，如果再找不到，就通过网络请求获取资源，再将资源存入 Service Worker 数据库中。</p> <h2 id="网络请求"><a href="#网络请求" class="header-anchor">#</a> 网络请求</h2> <p>通过网络请求的资源根据情况进行不同类型的缓存（一份文件可能会被多种类型缓存）：</p> <ol><li>根据 Service Worker 中的 handler 决定是否存入 Service Worker 数据库中。</li> <li>根据 HTTP 头部的相关字段(Cache-control, Pragma 等)决定是否存入 Disk Cache。</li> <li>Memory Cache 保存一份资源 的引用，以备下次使用。</li></ol> <h2 id="浏览器行为"><a href="#浏览器行为" class="header-anchor">#</a> 浏览器行为</h2> <p>通过不同的浏览器行为，会触发不同类型缓存的读取：</p> <ol><li>打开网页，地址栏输入地址： 查找 Disk Cache 中是否有匹配。如有则使用；如没有则发送网络请求。</li> <li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 Memory Cache 是可用的，会被优先使用(如果匹配的话)。其次才是 Disk Cache。</li> <li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，发送的请求头部均带有 Cache-control: no-cache (为了兼容，还带了 Pragma: no-cache)。服务器直接返回 200 和最新内容。</li></ol> <h2 id="案例"><a href="#案例" class="header-anchor">#</a> 案例</h2> <h3 id="memory-cache-disk-cache"><a href="#memory-cache-disk-cache" class="header-anchor">#</a> Memory Cache &amp; Disk Cache</h3> <p>一个简单页面 index.html，引用了一个 index.css 和 index.js。</p> <p>三种资源都设置了 <code>Cache-control: max-age=86400</code> 强制缓存 24 小时。</p> <p>第一次加载：三个资源都进行了网络请求。</p> <p>刷新页面：三个资源都从 Memory Cache 中获取。</p> <p>关闭再打开页面：三个资源都从 Disk Cache 中获取。</p> <h3 id="no-cache-no-store"><a href="#no-cache-no-store" class="header-anchor">#</a> no-cache &amp; no-store</h3> <p>一个简单页面 index.html，引入资源，代码如下：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 把3种资源都改成请求两次 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/static/index.css<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>stylesheet<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/static/index.css<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/static/index.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/static/index.js<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/static/mashroom.jpg<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/static/mashroom.jpg<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 异步请求图片 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> img <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">)</span>
        img<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'/static/mashroom.jpg'</span>
        document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>情况一：当服务器响应设置为 <code>Cache-Control: no-cache</code> 时：</p> <p>结果是相同的资源不会重复加载，而是从 Memory Cache 中取缓存，最终请求数为 3。</p> <p>情况二：当服务器响应设置为 <code>Cache-Control: no-store</code> 时：</p> <p>结果是三种资源都被请求了 2 次，而且图片还多了一次动态请求。</p> <h3 id="service-worker-memory-disk-cache"><a href="#service-worker-memory-disk-cache" class="header-anchor">#</a> Service Worker &amp; Memory(Disk) Cache</h3> <p>写一个 serviceWorker.js，指定要缓存的 3 个文件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// serviceWorker.js</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'install'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 当确定要访问某些资源时，提前请求并添加到缓存中。</span>
  <span class="token comment">// 这个模式叫做“预缓存”</span>
  e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'service-worker-test-precache'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">cache</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'/static/index.js'</span><span class="token punctuation">,</span> <span class="token string">'/static/index.css'</span><span class="token punctuation">,</span> <span class="token string">'/static/mashroom.jpg'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'fetch'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缓存中能找到就返回，找不到就网络请求，之后再写入缓存并返回。</span>
  <span class="token comment">// 这个称为 CacheFirst 的缓存策略。</span>
  <span class="token keyword">return</span> e<span class="token punctuation">.</span><span class="token function">respondWith</span><span class="token punctuation">(</span>
    caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'service-worker-test-precache'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">cache</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">matchedResponse</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> matchedResponse <span class="token operator">||</span> <span class="token function">fetch</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">fetchedResponse</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>request<span class="token punctuation">,</span> fetchedResponse<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">return</span> fetchedResponse
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 这个也叫做 NetworkOnly 的缓存策略，即不从数据库里找，直接去 Memory/Disk Cache 里找。</span>
<span class="token comment">// Network 里显示的还是 from ServiceWorker</span>
<span class="token comment">// self.addEventListener('fetch', e =&gt; {</span>
<span class="token comment">//    return e.respondWith(fetch(e.request))</span>
<span class="token comment">// })</span>
</code></pre></div><p>第一次加载：除了 3 次网络请求，还多了 3 次预缓存操作，共计 6 次。</p> <p>刷新或者关闭再打开：三个资源都是从 Service Worker 中获取。</p> <h2 id="缓存的应用"><a href="#缓存的应用" class="header-anchor">#</a> 缓存的应用</h2> <h3 id="不常变化的资源"><a href="#不常变化的资源" class="header-anchor">#</a> 不常变化的资源</h3> <p>设置一个长时间的强制缓存，比如 <code>Cache-Control: max-age=31536000</code>。</p> <p>如果需要更新资源，就需要在文件名(或者路径)中添加 hash，版本号等动态字符，之后更改动态字符，达到更改引用 URL 的目的，从而让之前的强制缓存失效。</p> <h3 id="经常变化的资源"><a href="#经常变化的资源" class="header-anchor">#</a> 经常变化的资源</h3> <p>这类资源的特点是：URL 不能变化，但内容可以(且经常)变化。我们可以设置 <code>Cache-Control: no-cache</code> 来迫使浏览器每次请求都必须找服务器验证资源是否有效。</p> <p>既然提到了验证，就必须 ETag 或者 Last-Modified 出场。这些字段都会由专门处理静态资源的常用类库(例如 koa-static)自动添加，无需开发者过多关心。</p> <h3 id="禁止缓存"><a href="#禁止缓存" class="header-anchor">#</a> 禁止缓存</h3> <p><code>Cache-Control: no-cache, no-store, must-revalidate</code></p> <h3 id="静态资源缓存"><a href="#静态资源缓存" class="header-anchor">#</a> 静态资源缓存</h3> <p><code>Cache-Control: public, max-age=31536000</code></p> <h3 id="特殊情况"><a href="#特殊情况" class="header-anchor">#</a> 特殊情况</h3> <p><code>Cache-Control: max-age=600, must-revalidate</code></p> <p>这是一种非常危险的设置，比如一个页面引入了 index1.js 和 index2.js，这两个文件相互依赖且都设置了上面的头信息。</p> <p>如果在 600 秒内，浏览器把 index1.js 缓存删除了，那么下次打开页面将加载新的 index1.js，此时如果这个新 js 发生了重大改动，则将导致和 index2.js 发生冲突，导致错误。</p> <p>这种短的 max-age 通常用在不需要其他依赖的文件中，比如图片、打包后的 js。</p> <h3 id="生产环境设置"><a href="#生产环境设置" class="header-anchor">#</a> 生产环境设置</h3> <p><a href="https://www.zhihu.com/question/278986273" target="_blank" rel="noopener noreferrer">链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">4/9/2023, 7:46:43 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/KokoTa_Home/front/JS的this.html" class="prev">
        JS的this
      </a></span> <span class="next"><a href="/KokoTa_Home/front/MVVM.html">
        MVVM
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/KokoTa_Home/assets/js/app.5aa2fc63.js" defer></script><script src="/KokoTa_Home/assets/js/2.f316d9e6.js" defer></script><script src="/KokoTa_Home/assets/js/28.cc74e010.js" defer></script>
  </body>
</html>
