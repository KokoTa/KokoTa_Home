(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{303:function(a,t,o){"use strict";o.r(t);var r=o(14),n=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"跨域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[a._v("#")]),a._v(" 跨域")]),a._v(" "),t("p",[a._v("我：拒绝访问？？？肿么回事？？？"),t("br"),a._v("\n他：是不是请求地址弄错了？\n我：Nope!不可能！\n他：我看看。。。嗯。。。确实。\n我：是吧！\n他：确实是跨域问题。\n我：啥？？？\n他：跨域啊！\n我：跨域是什么？\n他：。。。")]),a._v(" "),t("h2",{attrs:{id:"前端跨域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端跨域"}},[a._v("#")]),a._v(" 前端跨域")]),a._v(" "),t("p",[a._v("比如我们在A服务器上放了自己的网站，但是我们的资源都放在B服务器上，此时我们在A站上请求B站的资源，会发生什么？"),t("br"),a._v("\n当然会发生跨域问题啦，这是JS的安全机制所带来的局限，详细的踩雷图如下："),t("br"),a._v(" "),t("img",{attrs:{src:"/images/%E8%B7%A8%E5%9F%9F1.jpg",alt:"是否跨域的判断依据"}}),t("br"),a._v("\n上图也是"),t("strong",[a._v("同源策略")]),a._v("的判断依据，通过一些方式或技巧，我们可以实现跨域通信：")]),a._v(" "),t("ol",[t("li",[t("strong",[a._v("CORS跨域")]),a._v("：即服务器通过设置"),t("strong",[a._v("Access-Control-Allow-Origin")]),a._v("字段，允许所有或某些网站的请求。")]),a._v(" "),t("li",[t("strong",[a._v("JSONP跨域")]),a._v("：我们知道网页中引入的script资源是可以跨域的，比如"),t("code",[a._v('<script src="https://cdn.bootcss.com/bootstrap/4.1.0/js/bootstrap.bundle.js"><\/script>')]),a._v("。可以利用这一点在其他服务器上建立资源文件，通过script标签引入。一般来说JSONP请求后会触发一个自定义回调，这个回调函数的参数就是返回的资源数据。")]),a._v(" "),t("li",[t("strong",[a._v("window.name跨域")]),a._v("：window.name有一个特性，那就是同一个iframe下，不管你怎么切页面，从X站切到O站，window.name都是不变的，我们可以利用这个特点进行跨域通信。"),t("strong",[a._v("过程大致如下")]),a._v("：打开A站的页面a -> 页面a下创建iframe1 -> iframe1指向B站的页面b -> 页面b修改window.name -> 页面a改变iframe1 -> iframe1指向A站的页面aa（aa啥都没有） -> 由于此时a和aa是同源页面，因此a就可以取到window.name的内容了。")]),a._v(" "),t("li",[t("strong",[a._v("location.hash跨域")]),a._v("：这个也是通过iframe来进行通信。"),t("strong",[a._v("过程大致如下")]),a._v("：打开A站的页面a -> 在a下创建iframe1 -> iframe1指向B站的页面b -> b监听自己的hash值，如果hash发生改变 -> 就在b下创建iframe2 -> iframe2指向A站下的页面aa -> b改变aa的hash值 -> aa获得b的hash并赋值到a的hash上 -> a获得改变后的hash值。（PS：其实就是绕了一圈= =）")]),a._v(" "),t("li",[t("strong",[a._v("document.domain跨域")]),a._v("：这个需要服务器来配合，即接收和发送方的document.domain都设置成自身或更高一级的父域，且主域必须相同，具有一定局限性。比如发送方是"),t("code",[a._v("a.kokota.com")]),a._v("，那么document.domain就设置为"),t("code",[a._v("kokota.com")]),a._v("。")]),a._v(" "),t("li",[t("strong",[a._v("proxy跨域")]),a._v("：跨域跨域，只有前端才会跨域，后端服务器之间的通信木有跨域，因此我们可以设置一个代理，代替浏览器向其他服务器发送请求。Node下可以使用"),t("code",[a._v("http-proxy-middleware")]),a._v("插件进行代理。")]),a._v(" "),t("li",[t("strong",[a._v("WebSocket跨域")]),a._v("：页面a通过此协议可以连接服务器B，B可以对a进行推送。Node下可以使用"),t("code",[a._v("socket.io")]),a._v("进行实践。")])]),a._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/KokoTa/cross-domain",target:"_blank",rel:"noopener noreferrer"}},[a._v("demo"),t("OutboundLink")],1),a._v(" "),t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/04/cors.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("CORS的设置"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);